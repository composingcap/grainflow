{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 8,
			"minor" : 2,
			"revision" : 1,
			"architecture" : "x64",
			"modernui" : 1
		}
,
		"classnamespace" : "dsp.gen",
		"rect" : [ 42.0, 85.0, 1852.0, 939.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 10.0,
		"default_fontface" : 0,
		"default_fontname" : "Futura Medium",
		"gridonopen" : 1,
		"gridsize" : [ 15.0, 15.0 ],
		"gridsnaponopen" : 1,
		"objectsnaponopen" : 1,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"lefttoolbarpinned" : 0,
		"toptoolbarpinned" : 0,
		"righttoolbarpinned" : 0,
		"bottomtoolbarpinned" : 0,
		"toolbars_unpinned_last_save" : 0,
		"tallnewobj" : 0,
		"boxanimatetime" : 200,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"style" : "Minimal",
		"subpatcher_template" : "minimal",
		"assistshowspatchername" : 0,
		"boxes" : [ 			{
				"box" : 				{
					"id" : "obj-18",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 992.0, 723.0, 35.0, 21.0 ],
					"text" : "out 7"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-17",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 958.0, 769.0, 150.0, 19.0 ],
					"text" : "Window of the grain"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-16",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 897.0, 728.0, 35.0, 21.0 ],
					"text" : "out 6"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-11",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 766.0, 794.0, 150.0, 19.0 ],
					"text" : "Peak amp of the grain"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-6",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 793.0, 756.0, 35.0, 21.0 ],
					"text" : "out 5"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-15",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 1019.333333333333371, 50.0, 150.0, 19.0 ],
					"text" : "Amplitude Modulation"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-14",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 693.333333333333371, 37.0, 150.0, 19.0 ],
					"text" : "Frequency Modulation"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-13",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 371.666666666666686, 37.0, 150.0, 19.0 ],
					"text" : "Grain Clock (phasor)"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-12",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 52.0, 37.0, 150.0, 19.0 ],
					"text" : "Traversal Position (0-1)"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-10",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 556.0, 748.0, 150.0, 19.0 ],
					"text" : "Position of the playhead"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-9",
					"linecount" : 2,
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 400.0, 769.0, 150.0, 31.0 ],
					"text" : "Progress of the grain from 0-1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-8",
					"linecount" : 3,
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 219.666666666666742, 752.0, 150.0, 43.0 ],
					"text" : "Stage of the grain\n0 : done\n1: running "
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-7",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 73.0, 844.0, 150.0, 19.0 ],
					"text" : "Grain output"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-5",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 986.0, 14.0, 107.0, 21.0 ],
					"text" : "in 4 @comment am"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-4",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 664.333333333333371, 14.0, 105.0, 21.0 ],
					"text" : "in 3 @comment fm"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-3",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 600.0, 714.0, 35.0, 21.0 ],
					"text" : "out 4"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-2",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 410.333333333333371, 723.0, 35.0, 21.0 ],
					"text" : "out 3"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-1",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 342.666666666666686, 14.0, 151.0, 21.0 ],
					"text" : "in 2 @comment grainPhasor"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-23",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 214.0, 718.0, 35.0, 21.0 ],
					"text" : "out 2"
				}

			}
, 			{
				"box" : 				{
					"code" : "/*\r\ngrainflow.voice is a sample accurate grain instance which occures on a rotated phasor that is shared between multiple grains. \r\n\r\n\r\n\r\n*/\r\n\r\n//Functions \r\nrandom(pole){\r\n\t/*\r\n\t\tCreates a random number with polarity\r\n\t*/\t\r\n\tif (pole < 0){\r\n\t\treturn (noise()+1)/2*-1;\r\n\t\t}\t\r\n\telse if (pole > 0){\r\n\t\treturn (noise()+1)/2;\r\n\t\t}\r\n\t\r\n\telse {\r\n\t\treturn noise();\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n// Buffers \r\n\r\nBuffer buf(); //Buffer to read\r\nBuffer travOffsets(); //Buffer of Traversal Offsets\r\nBuffer env(); //Envelope Shape\r\nBuffer env2D(); //2D wavetable of envelopes\r\nBuffer windowOffsets(); //buffer of window offsets\r\nBuffer rates(); // buffer of rates\r\nBuffer glisson2D(); //not a thing yet\r\n\r\n//Parame\r\n\r\nParam bufChan(1);\r\nParam chans(1);\r\n\r\n//Modes\r\n/* \r\nModes alter how the granulator reads certain message or determines if it will read from parameter buffers  \r\n*/\r\nParam envMode(0); // 0 is standard envelope read, 1 is a lookup from a 2D wavetable\r\nParam windowOffsetMode(0); //0 is algorythmic linear offset, 1 is read from a buffer based on voice with a random offset in ms, 3 is read from a buffer by voice with random effecting the read position from that buffer\r\nParam rateMode(0); // 0 is algorythmic, 1 is lookup with random offset, 2 is lookup with randomized lookup position\r\nParam glissonMode(0); // 0 is algorythmic, 1 is lookup with random offset, 2 is lookup with randomized lookup position\r\nParam triggerMode(0); // Used for triggering grains with control messages\r\nParam polarityMode(0); //Switches the polarity of the grain every envelope.  This can help when there are a large number of grains close together\r\nParam state(1);\r\n\r\n//Generic Parameters\r\nParam sampleRateCorrection(1.); //The factor at which the grain needs to be played if the sample rate is different in the buffer from maz\r\nParam forceGrainReset(0);\r\nParam loopMode(1);\r\nParam randomPole(1); // 0 is biPolar, -1 is neg, +1 is pos\r\n\r\n\r\n//Amplitude\r\nParam amp(1.); //The amplitude of this grain\r\nParam ampRandom(0.);// the random amplitude of this grina\r\n\r\n//Traversal\r\nParam travGlobalOffset(0); // Global Traversal offset in ms\r\nParam travRandom(0); // Traversal Random in ms\r\nParam travOffset(0); // Traversal offset in ms per voice\r\nParam travMode(0); // 0 is normal, 1 reads from the buffer\r\n\r\nParam phasorRate(1); //A multiplier for the phasor rate\r\nParam phasorRateRandom(0); // a random modifier for the phasor rate\r\n\r\nParam space(0); //The amound of space for each cycle.  Set as a proportion.\r\nParam spaceRandom(0); //The random amound of space in the grain phasor\r\n\r\n//Window Offset\r\nParam windowOffset(0); // Grain offset on phasor per voice\r\nParam windowOffsetRandom(0); //Noise to the grain offset position\r\nParam windowReadBias(0);\r\nParam windowReadBiasRandom(0);\r\n\r\n//Playback rate\r\nParam rate(1); //playRate\r\nParam rateRandom(0); // Random playback rate\r\nParam rateOffset(0); // The platback rate offset based on the grain index\r\nParam rateQuantizeSemi(0); // A semitone quantization to apply to rate\r\nParam direction(1); // The probablistic dirrection of each grain 1 is always forward -1 is always backward\r\nParam density(1);\r\n\r\nParam glisson(0); //The change in rate from the start to the end of the grain\r\nParam glissonRandom(0); //The change in rate from the start to the end of the grain\r\nParam glisson2DNumber(1); //The number of glissonshapes an external buffer glisson2D **Not implemented\r\n\r\n//2D Envelope -- 2D wavetables for envelopes \r\nParam env2DOffset(0); //The offest in the 2Denv buffer\r\nParam env2DPosition(0); //The overall position in the 2Denv buffer\r\nParam env2DRandom(0); //The randomness applied to the position the 2Denv buffer\r\nParam env2DNumber(1); // The number of entries in the env2D buffer\r\nParam chanMode(0);\r\n\r\nParam startPoint(0);\r\nParam stopPoint(1);\r\n\r\n//Feedback\r\n\r\nParam feedback(0);\r\n\r\nParam noPlay(0);\r\n\r\nParam fmLock(0);\r\nParam amLock(0);\r\n\r\n//History \r\nHistory thisEnvMode(0); //The envelope mode stored for this grain\r\nHistory startTime(0); \r\nHistory lastGrainProgress(9999999); //The progress of the last grain- used to reset the grain\r\nHistory grainStage(0);\r\nHistory thisDuration(0);\r\nHistory sampleCounter(0);\r\nHistory thisSpace(0);\r\nHistory windowPortion(1); \r\nHistory playRate(0); //The playRate determined for this grain\r\nHistory myOffset(0); //The offest determined for this grain\r\nHistory myGlisson(0); //The glisson determined for this grain\r\nHistory myEnv2DOffset(0);\r\n\r\nHistory env2DLower(0);\r\nHistory env2DUpper(0);\r\nHistory env2DMix(0);\r\n\r\nHistory myReadBias(1);\r\nHistory myPhasorRate(1);\r\nHistory myDirection(1);\r\nHistory myAmp(1);\r\nHistory polarity(0);\r\nHistory initalized(0);\r\nHistory firstGrain(0);\r\nHistory grainEnabled(0);\r\nHistory myChannel(0);\r\n\r\n\r\ntrav = in1;\r\ntrav = wrap(trav,0,1);\r\nplayHead = 0;\r\nclock = wrap(in2,0,1);\r\nfm = in3;\r\nam = 1-fold(in4,0,1);\r\n\r\nif (state == 1){\r\n\r\n//These happen every sample\r\n\r\n\r\n\r\ngrainNoise = 0;\r\nwindow = 0;\r\nthisGrain = 0;\r\ngPos = 0;\r\n\r\nwritePosition = in1*dim(buf);\r\n\r\ngrainReset = change(forceGrainReset)!=0;\r\n\r\nthisVoicecount = voicecount+mc_channelcount;\r\nthisVoice = voice+mc_channel-2;\r\nvoiceRatio = thisVoice/thisVoicecount;\r\n\r\n\r\n\r\nif (initalized == 0 || grainReset){\r\n\t\r\n\t//Only happens on the first frame audio is on, or if it is set to 0\r\n\t\r\n\tpolarity = ((noise()>0)*2-1);\r\n\tinitalized = 1;\r\n\tfirstGrain = 1;\r\n\tlastGrainProgress = 999;\r\n\t\r\n\t\r\n\t\t\tif (windowOffsetMode == 0){\r\n\t\t\tmyOffset = windowOffset*(thisVoice)+windowOffsetRandom*random(randomPole);\r\n\t\t}\r\n\t\r\n\t\telse if (windowOffsetMode == 1) {\r\n\t\t\tmyOffset = peek(windowOffsets,thisVoice, interp=\"none\", boundmode=\"wrap\")+windowOffsetRandom*random(randomPole);\r\n\t\t\r\n\t\t\t}\r\n\t\telse if (windowOffsetMode == 2){\r\n\t\t\t\r\n\t\t\tmyOffset = peek(windowOffsets,voiceRatio+windowOffsetRandom*random(randomPole), interp=\"linear\",index=\"phase\", boundmode=\"wrap\");\r\n\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\tif (chanMode == 0){\r\n\t\t\t\r\n\t\t\tmyChannel = bufChan - 1;\r\n\t\t\t}\r\n\t\telse if (chanMode == 1){\r\n\t\t\tmyChannel = floor(random(1)*(chans-0.0001));\r\n\t\t\t}\r\n\t\r\n\t}\r\n\t\r\ngrainProgress = wrap(rate(wrap(clock + myOffset, 0, 1),myPhasorRate),0,1);\r\n\r\n\r\nif (((lastGrainProgress > grainProgress))){\r\n\t\r\n\t//Happens at the start of the grain\t\r\n\tfirstGrain = 0;\r\n\t\r\n\tgrainEnabled = ((noise()+1)*0.5 < density) ;\r\n\t\r\n\tmyAmp = amp*(1 - random(1)*ampRandom) * polarity;\r\n\t\r\n\tif (amLock == 1){\r\n\t\tmyAmp *= am;\r\n\t\t\r\n\t\t}\r\n\t\r\n\tpolarity = polarity * -1;\r\n\t\r\n\tpolarity = polarityMode*polarity + (1-polarityMode);\r\n\t\r\n\tif (!triggerMode){\r\n\tmyPhasorRate= phasorRate+phasorRateRandom*random(randomPole);\r\n\t\r\n\t}\r\n\t\r\n\telse{\t\t\r\n\t\tmyPhasorRate = 1;\r\n\t\t\r\n\t\t}\r\n\tstartTime = 0;\r\n\t\r\n\t//Traversal\r\n\t\r\n\tif (travMode == 0){\r\n\tstartTime = trav*dim(buf) - fixnan(mstosamps(travRandom*random(1)+travOffset*thisVoice+travGlobalOffset))*sampleRateCorrection;\r\n\t}\r\n\t\r\n\telse if (travMode == 1){\r\n\tstartTime = trav*dim(buf) + fixnan(mstosamps(peek(travOffsets, thisVoice,boundmode=\"wrap\")))*sampleRateCorrection- fixnan(mstosamps(travRandom*random(1)+travOffset*thisVoice+travGlobalOffset))*sampleRateCorrection;\t\r\n\t\t}\r\n\t\r\n\telse if (travMode == 2){\r\n\tstartTime = trav*dim(buf) + fixnan(mstosamps(peek(travOffsets, fixnan(random(1)), index=\"phase\", boundmode=\"wrap\")))*sampleRateCorrection- fixnan(mstosamps(travRandom*random(1)+travOffset*thisVoice+travGlobalOffset))*sampleRateCorrection;\t\r\n\t\t}\r\n\t\r\n\tif (loopMode == 2){\r\n\t\tstartTime = fold(startTime,startPoint*dim(buf),stopPoint*dim(buf));\r\n\r\n\t\t}\r\n\t\r\n\tif (chanMode == 0){\r\n\t\t\t\r\n\t\tmyChannel = bufChan - 1;\r\n\t\t\t}\r\n\telse if (chanMode == 1){\r\n\t\tmyChannel = floor(random(1)*(chans-0.0001));\r\n\t\t}\r\n\t\t\r\n\r\n\t//Determine window portion based on space\r\n\t\r\n\twindowPortion = 1-clip(space+spaceRandom*random(randomPole),0,1);\r\n\t\r\n\t\r\n\t//Glisson\r\n\t\r\n\t\r\n\tif (glissonMode == 0){\r\n\t\r\n\tmyGlisson = (glisson+random(randomPole)*glissonRandom);\r\n\t}\r\n\t\r\n\tif (glissonMode == 1){\r\n\t\t//Will be similar to 2D Wt lookup\r\n\t\t\r\n\t\t}\r\n\t\r\n\t//Rate\r\n\t\r\n\tif (rateMode == 0){\r\n\t\r\n\tplayRate = rate+rateRandom*random(randomPole)+rateOffset*voice;\r\n\t\r\n\t\r\n\t}\r\n\r\n\t\r\n\telse if (rateMode == 1){\r\n\t\t//Rates per voice;\r\n\t\tplayRate = peek(rates,thisVoice, interp = \"none\")+rateRandom*random(randomPole);\t\t\r\n\t\t}\r\n\telse if (rateMode == 2){\r\n\t\t//By voice, read point random\r\n\t\tplayRate = peek(rates,(voiceRatio+random(randomPole)), interp = \"none\", index=\"phase\",boundmode=\"wrap\")+rateRandom*random(randomPole);\t\t\r\n\t\t}\r\n\t\t\r\n\tif (rateQuantizeSemi > 0){\r\n\t\t\r\n\t\tplayRate = 1+round(playRate-1, 1-pow(2,rateQuantizeSemi/12));\r\n\t\t\r\n\t\t}\r\n\t\r\n\tif (fmLock==1){\r\n\t\tplayRate += fm;\r\n\t\t}\r\n\t\r\n\t// Play Direction\t\r\n\t\r\n\tif (direction >= 1){\r\n\t\r\n\tmyDirection = 1;\r\n\t}\r\n\telse if (direction <= -1){\r\n\tmyDirection = -1;\r\n\t}\r\n\telse{\r\n\trandomDirection = noise();\r\n\tif (randomDirection > direction){\r\n\t\tmyDirection = -1;\r\n\t\t}\r\n\telse {\r\n\t\tmyDirection = 1;\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\t// If the grain was triggered be a message \r\n\tif(triggerMode){\r\n\t\tmyOffset = 0;\r\n\t}\r\n\t\r\n\t\t\r\n\t//If it was not triggered (normal) \t\t\t\r\n\telse{\r\n\t\t//Window offset (position on phasor) \r\n\t\t\r\n\t\tif (windowOffsetMode == 0){\r\n\t\t\tmyOffset = windowOffset*thisVoice+windowOffsetRandom*random(randomPole);\r\n\t\t}\r\n\t\r\n\t\telse if (windowOffsetMode == 1) {\r\n\t\t\tmyOffset = (peek(windowOffsets,voiceRatio, interp=\"none\",index=\"phase\"))+windowOffsetRandom*random(randomPole);\r\n\t\t\r\n\t\t\t}\r\n\t\telse if (windowOffsetMode == 2){\r\n\t\t\t\r\n\t\t\tmyOffset = (peek(windowOffsets,random(randomPole), interp=\"none\",index=\"phase\", boundmode=\"wrap\"));\r\n\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\r\n\r\n\t//Window read bias\r\n\tif (windowReadBias != 0 || windowReadBiasRandom != 0){\r\n\t\tmyReadBias = pow(2,windowReadBias + random(randomPole)*windowReadBiasRandom);\r\n\t}\r\n\telse {\r\n\t\tmyReadBias = 1;\r\n\t\t}\r\n\t\r\n\t//Envelope setup\t\t\r\n\tif (envMode == 1){\r\n\t\tthisEnvMode = 1;\r\n\t\tmyEnv2DOffset = wrap(env2DOffset*voice + env2DPosition + env2DRandom*random(randomPole), 0,1);\r\n\t\tenv2DLower = floor(myEnv2DOffset*env2DNumber)/env2DNumber;\r\n\t\tenv2DUpper = ceil(myEnv2DOffset*env2DNumber)/env2DNumber; \r\n\t\tenv2DMix =  myEnv2DOffset*env2DNumber%1;\r\n\t\t}\r\n\telse{\r\n\t\tthisEnvMode = 0;\r\n\t\t}\r\n\t\t\r\n\t\t\t\r\n\tsampleCounter = 0;\t\r\n\t\r\n\t\r\n\t\r\n\t}\r\n\r\n// Happens for the duration of the window\r\n\r\nelse if (grainProgress <= windowPortion && !firstGrain){\r\n\t\r\n\twindowProgress = 0;\r\n\t\r\n\t//Run read bias for the window\r\n\tif (myReadBias != 1){\r\n\twindowProgress = fixnan(pow(grainProgress/windowPortion, myReadBias));\r\n\t}\r\n\telse{\r\n\t\twindowProgress = grainProgress/windowPortion;\r\n\t\t}\r\n\t\r\n\twindow = 0;\r\n\t\r\n\t//Read the window\r\n\tif (thisEnvMode == 0){\t\r\n\twindow = slide(peek(env, windowProgress, index=\"phase\", interp= \"linear\", boundmode=\"wrap\"),100,100);\r\n\t}\r\n\telse if (thisEnvMode ==1){\r\n\t\tenv2DProgress = windowProgress/env2DNumber;\r\n\r\n\t\twindowA = peek(env2D, env2DProgress+env2DLower, index=\"phase\", boundmode=\"wrap\");\r\n\t\twindowB = peek(env2D, env2DProgress+env2DUpper, index=\"phase\", boundmode=\"wrap\");\r\n\t\twindow = windowA*(1-env2DMix) + windowB*env2DMix;\r\n\t\t}\r\n\t\t\r\n\twindow = slide(window, 50,0);\r\n\t\t\r\n\t//Read the grai\r\n\t//Alows the grain to wrap around\r\n\tif (!noPlay){\r\n\t\t\r\n\t\t\r\n\t\tthisAm = am; \r\n\t\tif (amLock == 1){\r\n\t\t\tthisAm = 1;\r\n\t\t\t}\r\n\r\n\tif (loopMode == 1 || loopMode == 2){\r\n\t\tgPos = wrap((startTime+sampleCounter),startPoint*dim(buf),stopPoint*dim(buf));\r\n\t\tthisGrain = peek(buf, gPos, myChannel,  interp=\"linear\",boundmode=\"wrap\")*window*(thisAm);\r\n\t}\r\n\r\n\telse if (loopMode == 3){\r\n\t\tgPos = fold((startTime+sampleCounter),startPoint*dim(buf),stopPoint*dim(buf));\r\n\t\tthisGrain = peek(buf, gPos, myChannel,  interp=\"linear\",boundmode=\"wrap\")*window*(thisAm);\r\n\t\t}\r\n\t//Clip the grain\r\n\telse{\r\n\t\tgpos = startTime+sampleCounter;\r\n\t\tthisGrain = peek(buf, gpos ,myChannel,  interp=\"linear\",boundmode=\"clip\")*window*(thisAm);\r\n\t\t}\r\n\t\t}\r\n\t\r\n\tplayHead = (startTime+sampleCounter)/dim(buf);\r\n\t\t\t\t\t\t\r\n\tsampleCounter += (playRate+(fm*(fmLock==0))+myGlisson*windowProgress)*myDirection*sampleRateCorrection;\r\n\r\n\t\r\n\tgrainStage = 1;\r\n\t\r\n\t}\r\n//Empty space \t\r\nelse{\r\n\tgrainStage = 0;\r\n\tthisGrain = 0;\r\n\tplayHead = -1;\r\n\t}\r\n\t\r\n\t\r\n\r\n\r\n\r\nlastGrainProgress = grainProgress;\t\r\n\r\n\r\n\t\r\n\t\r\n\r\nout1 = thisGrain*myAmp*grainEnabled;\r\nout2 = grainStage;\r\nout3 = grainProgress*grainEnabled;\r\nout4 = gPos/dim(buf);\r\nout5 = abs(myAmp)*grainEnabled;\r\nout6 = abs(window)*grainEnabled;\r\nout7 = (myChannel+1)*grainEnabled; \r\nif (feedback != 0){\r\n\t//This does not really work- it is better to just use tapin/tapout\r\n\ttravsamps = trav*dim(buf)-1;\r\n\tpoke(buf, thisGrain*myAmp*feedback + peek(buf,travsamps,0) , travsamps, 0, boundmode=\"wrap\"); \r\n\t\r\n\r\n}\r\n}\r\n\r\nelse{\r\n\tinitalized = 0;\r\n\t}",
					"fontface" : 0,
					"fontname" : "<Monospaced>",
					"fontsize" : 10.0,
					"id" : "obj-22",
					"maxclass" : "codebox",
					"numinlets" : 4,
					"numoutlets" : 7,
					"outlettype" : [ "", "", "", "", "", "", "" ],
					"patching_rect" : [ 21.0, 64.0, 984.0, 635.0 ]
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-21",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 21.0, 844.0, 35.0, 21.0 ],
					"text" : "out 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-20",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 21.0, 14.0, 174.0, 21.0 ],
					"text" : "in 1 @comment traversalPosition"
				}

			}
 ],
		"lines" : [ 			{
				"patchline" : 				{
					"destination" : [ "obj-22", 1 ],
					"source" : [ "obj-1", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-22", 0 ],
					"source" : [ "obj-20", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-16", 0 ],
					"source" : [ "obj-22", 5 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-18", 0 ],
					"source" : [ "obj-22", 6 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-2", 0 ],
					"source" : [ "obj-22", 2 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-21", 0 ],
					"source" : [ "obj-22", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-23", 0 ],
					"source" : [ "obj-22", 1 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-3", 0 ],
					"source" : [ "obj-22", 3 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-6", 0 ],
					"source" : [ "obj-22", 4 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-22", 2 ],
					"source" : [ "obj-4", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-22", 3 ],
					"source" : [ "obj-5", 0 ]
				}

			}
 ],
		"autosave" : 0,
		"styles" : [ 			{
				"name" : "Minimal",
				"default" : 				{
					"bgfillcolor" : 					{
						"type" : "color",
						"color" : [ 0.65098, 0.666667, 0.662745, 1.0 ],
						"color1" : [ 0.65098, 0.666667, 0.662745, 1.0 ],
						"color2" : [ 0.290196, 0.309804, 0.301961, 1.0 ],
						"angle" : 270.0,
						"proportion" : 0.39,
						"autogradient" : 0.0
					}
,
					"fontname" : [ "Futura Medium" ],
					"bgcolor" : [ 0.999999, 0.999974, 0.999991, 1.0 ],
					"editing_bgcolor" : [ 0.956862745098039, 0.956862745098039, 0.956862745098039, 1.0 ],
					"accentcolor" : [ 0.0, 0.0, 0.0, 1.0 ],
					"fontface" : [ 0 ],
					"selectioncolor" : [ 0.0, 0.0, 0.0, 1.0 ],
					"elementcolor" : [ 0.694117647058824, 0.694117647058824, 0.694117647058824, 1.0 ],
					"clearcolor" : [ 1.0, 1.0, 1.0, 0.0 ],
					"fontsize" : [ 10.0 ],
					"textcolor_inverse" : [ 0.0, 0.0, 0.0, 1.0 ],
					"color" : [ 0.0, 0.0, 0.0, 1.0 ]
				}
,
				"parentstyle" : "",
				"multi" : 0
			}
 ]
	}

}
